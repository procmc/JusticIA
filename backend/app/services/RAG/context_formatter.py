"""
M√≥dulo para formateo de contexto y extracci√≥n de metadatos de documentos
"""
from typing import List, Dict, Any
from langchain_core.documents import Document


def format_documents_context_extended(docs: List[Document], max_docs: int = 5, use_full_chunks: bool = True) -> str:
    """
    Formateo EXTENDIDO que aprovecha al m√°ximo el chunking del m√≥dulo de ingesta.
    Usa chunks completos de 7000 caracteres cada uno para evitar alucinaciones.
    
    Args:
        docs: Lista de documentos de LangChain (chunks de 7000 chars c/u)
        max_docs: N√∫mero m√°ximo de chunks a incluir (5 = ~35,000 caracteres, balance √≥ptimo)
        use_full_chunks: Si True, usa chunks completos sin truncar
    
    Returns:
        Contexto formateado con informaci√≥n completa de chunks
    """
    if not docs:
        return "No hay informaci√≥n disponible."
    
    context_parts = []
    docs_to_use = docs[:min(len(docs), max_docs)]
    
    total_chars = 0
    for i, doc in enumerate(docs_to_use, 1):
        # Extraer metadatos del chunk
        expediente = doc.metadata.get("numero_expediente", doc.metadata.get("expediente_numero", "Sin expediente"))
        archivo = doc.metadata.get("nombre_archivo", doc.metadata.get("archivo", "Sin archivo"))
        tipo_documento = doc.metadata.get("tipo_documento", "documento")
        indice_chunk = doc.metadata.get("indice_chunk", i-1)
        total_chunks = doc.metadata.get("meta", {}).get("total_chunks", "desconocido")
        pagina_inicio = doc.metadata.get("pagina_inicio", "N/A")
        pagina_fin = doc.metadata.get("pagina_fin", "N/A")
        chunk_length = doc.metadata.get("meta", {}).get("chunk_length", len(doc.page_content))
        relevancia = doc.metadata.get("relevance_score", 0)
        
        # Usar contenido completo del chunk (sin truncar)
        content = doc.page_content
        if not use_full_chunks and len(content) > 6000:
            # Solo truncar si se solicita expl√≠citamente
            truncated = content[:6000]
            last_period = truncated.rfind('.')
            if last_period > 5500:
                content = truncated[:last_period + 1] + "...[TRUNCADO]"
            else:
                content = truncated + "...[TRUNCADO]"
        
        total_chars += len(content)
        
        context_parts.append(
            f"**üìã DOCUMENTO {i}/{len(docs_to_use)} - CHUNK {indice_chunk+1}/{total_chunks}**\n"
            f"üî¢ Expediente: {expediente}\n"
            f"üìÑ Archivo: {archivo}\n"
            f"üìë Tipo: {tipo_documento}\n"
            f"üìç P√°ginas: {pagina_inicio}-{pagina_fin}\n"
            f"üìä Tama√±o chunk: {chunk_length:,} caracteres\n"
            f"üéØ Relevancia: {relevancia:.3f}\n"
            f"üìù **CONTENIDO COMPLETO DEL CHUNK:**\n{content}\n"
        )
    
    header = f"**üîç CONTEXTO EXTENDIDO - {len(docs_to_use)} CHUNKS ({total_chars:,} caracteres)**\n"
    separator = "\n" + "="*100 + "\n"
    
    return header + separator.join(context_parts) + separator


def format_documents_context(docs: List[Document], max_docs: int = 15, max_chars_per_doc: int = 1000) -> str:
    """
    Formatea documentos para el contexto del LLM - Optimizado para informaci√≥n detallada de expedientes
    
    Args:
        docs: Lista de documentos de LangChain
        max_docs: N√∫mero m√°ximo de documentos a incluir (15 para an√°lisis completo)
        max_chars_per_doc: Caracteres m√°ximos por documento (1000 para informaci√≥n muy detallada)
    
    Returns:
        Contexto formateado como string con informaci√≥n completa
    """
    if not docs:
        return "No hay informaci√≥n disponible."
    
    context_parts = []
    # Aumentar documentos para an√°lisis m√°s completo
    docs_to_use = docs[:min(len(docs), max_docs)]
    
    for i, doc in enumerate(docs_to_use, 1):
        expediente = doc.metadata.get("expediente_numero", "Sin expediente")
        archivo = doc.metadata.get("archivo", "Sin archivo")
        materia = doc.metadata.get("materia", "Sin especificar")
        sede_judicial = doc.metadata.get("sede_judicial", "Sin sede")
        fecha = doc.metadata.get("fecha", "Sin fecha")
        tipo_documento = doc.metadata.get("tipo_documento", "Sin tipo")
        relevancia = doc.metadata.get("relevance_score", 0)
        
        # M√ÅS contenido para informaci√≥n MUY detallada
        content = doc.page_content
        if len(content) > max_chars_per_doc:
            # Truncar de manera inteligente, buscando el final de una oraci√≥n
            truncated = content[:max_chars_per_doc]
            last_period = truncated.rfind('.')
            if last_period > max_chars_per_doc - 150:  # Buscar m√°s lejos para m√°s contenido
                content = truncated[:last_period + 1] + "..."
            else:
                content = truncated + "..."
        
        context_parts.append(
            f"**üìã EXPEDIENTE {i} - INFORMACI√ìN COMPLETA**\n"
            f"üî¢ N√∫mero de Expediente: {expediente}\n"
            f"‚öñÔ∏è Materia Judicial: {materia}\n"
            f"üèõÔ∏è Sede Judicial: {sede_judicial}\n"
            f"üìÑ Tipo de Documento: {tipo_documento}\n"
            f"üìÖ Fecha: {fecha}\n"
            f"üìÅ Archivo Fuente: {archivo}\n"
            
            f"üéØ Relevancia: {relevancia:.2f}\n"
            f"üìù **CONTENIDO DETALLADO:**\n{content}\n"
        )
    
    return "\n" + "="*80 + "\n".join(context_parts) + "\n" + "="*80

def calculate_optimal_retrieval_params(query_length: int, context_importance: str = "high") -> Dict[str, int]:
    """
    Calcula par√°metros √≥ptimos de recuperaci√≥n basado en la consulta y importancia del contexto.
    
    Args:
        query_length: Longitud de la consulta en caracteres
        context_importance: "low", "medium", "high", "maximum"
    
    Returns:
        Dict con par√°metros optimizados: top_k, max_docs_context, target_chars
    """
    # Configuraciones OPTIMIZADAS para mejor relevancia y menos ruido
    configs = {
        "low": {"base_top_k": 3, "max_docs": 3, "target_chars": 21000},      # Consultas muy espec√≠ficas
        "medium": {"base_top_k": 4, "max_docs": 4, "target_chars": 28000},   # Consultas normales  
        "high": {"base_top_k": 5, "max_docs": 5, "target_chars": 35000},     # Consultas complejas
        "maximum": {"base_top_k": 6, "max_docs": 6, "target_chars": 42000}   # An√°lisis exhaustivo
    }
    
    config = configs.get(context_importance, configs["high"])
    
    # Ajustar top_k basado en longitud de consulta
    if query_length > 500:  # Consulta muy espec√≠fica
        top_k = config["base_top_k"] + 2
    elif query_length > 200:  # Consulta detallada
        top_k = config["base_top_k"] + 1
    else:  # Consulta simple
        top_k = config["base_top_k"]
    
    return {
        "top_k": min(top_k, 15),  # L√≠mite m√°ximo
        "max_docs_context": config["max_docs"],
        "target_chars": config["target_chars"]
    }


def format_documents_context_adaptive(docs: List[Document], query: str = "", context_importance: str = "high") -> str:
    """
    Formateo adaptativo que ajusta autom√°ticamente los par√°metros seg√∫n la consulta.
    Combina el chunking del m√≥dulo de ingesta con par√°metros inteligentes.
    
    Args:
        docs: Lista de documentos de LangChain
        query: Consulta original (para ajustar par√°metros)
        context_importance: Nivel de importancia del contexto
    
    Returns:
        Contexto formateado de manera √≥ptima
    """
    if not docs:
        return "No hay informaci√≥n disponible."
    
    # Calcular par√°metros √≥ptimos
    params = calculate_optimal_retrieval_params(len(query), context_importance)
    
    # Usar formateo extendido con par√°metros calculados
    return format_documents_context_extended(
        docs, 
        max_docs=params["max_docs_context"], 
        use_full_chunks=True
    )


def extract_document_sources(docs: List[Document]) -> List[Dict[str, Any]]:
    """
    Extrae informaci√≥n completa de fuentes para referencias detalladas
    """
    fuentes = []
    for doc in docs:
        fuente = {
            "expediente": doc.metadata.get("expediente_numero", ""),
            "archivo": doc.metadata.get("archivo", ""),
            "materia": doc.metadata.get("materia", ""),
            "sede_judicial": doc.metadata.get("sede_judicial", ""),
            "fecha": doc.metadata.get("fecha", ""),
            "tipo_documento": doc.metadata.get("tipo_documento", ""),
            "relevancia": doc.metadata.get("relevance_score", 0),
            "fragmento_completo": _truncate_text_smart(doc.page_content, 1000),  # M√ÅS informaci√≥n
            "resumen": _extract_summary(doc.page_content),  # Nuevo: resumen inteligente
            "palabras_clave": _extract_keywords(doc.page_content)  # Nuevo: palabras clave
        }
        fuentes.append(fuente)
    return fuentes

# Funci√≥n para detectar solicitudes de m√°s informaci√≥n
def should_use_detailed_format(query: str) -> bool:
    """
    Detecta si la consulta solicita informaci√≥n detallada
    """
    detailed_keywords = [
        'm√°s informaci√≥n', 'mas informaci√≥n', 'm√°s detalles', 'mas detalles',
        'qu√© m√°s', 'que mas', 'informaci√≥n adicional', 'detalles adicionales',
        'profundizar', 'ampliar', 'extender', 'completo', 'detallado',
        'todo lo que sabes', 'toda la informaci√≥n', 'informaci√≥n completa',
        'm√°s datos', 'mas datos', 'informaci√≥n espec√≠fica', 'espec√≠fico', 'detalladamente',
        'en detalle', 'desglosar', 'desglose', 'pormenores', 'pormenorizado','general'
    ]
    
    query_lower = query.lower()
    return any(keyword in query_lower for keyword in detailed_keywords)

# Funci√≥n inteligente que selecciona el formato seg√∫n la consulta
def format_context_intelligent(docs: List[Document], query: str = "") -> str:
    """
    Selecciona autom√°ticamente el formato m√°s apropiado seg√∫n la consulta
    """
    if should_use_detailed_format(query):
        # Usar formato MUY detallado para solicitudes espec√≠ficas
        return format_documents_context(docs, max_docs=15, max_chars_per_doc=1500)
    elif len(docs) <= 5:
        # Para pocos documentos, mostrar todo el contenido
        return format_documents_context(docs, max_docs=5, max_chars_per_doc=2000)
    else:
        # Formato est√°ndar pero generoso
        return format_context_compact(docs, max_docs=12)

def extract_unique_expedientes(docs: List[Document]) -> List[str]:
    """
    Extrae lista de expedientes √∫nicos de los documentos
    
    Args:
        docs: Lista de documentos de LangChain
    
    Returns:
        Lista de n√∫meros de expediente √∫nicos
    """
    expedientes = set()
    for doc in docs:
        exp_num = doc.metadata.get("expediente_numero", "")
        if exp_num and exp_num.strip():
            expedientes.add(exp_num)
    
    return list(expedientes)

def extract_materias_judiciales(docs: List[Document]) -> List[str]:
    """
    Extrae las materias judiciales √∫nicas de los documentos
    
    Args:
        docs: Lista de documentos de LangChain
    
    Returns:
        Lista de materias judiciales √∫nicas ordenadas
    """
    materias = set()
    for doc in docs:
        materia = doc.metadata.get("materia", "")
        if materia and materia.strip():
            materias.add(materia.strip())
    
    return sorted(list(materias))

def _truncate_text(text: str, max_length: int) -> str:
    """Trunca texto a longitud m√°xima con elipsis"""
    if len(text) <= max_length:
        return text
    return text[:max_length] + "..."

def _truncate_text_smart(text: str, max_length: int) -> str:
    """
    Trunca texto de manera inteligente, respetando oraciones completas
    """
    if len(text) <= max_length:
        return text
    
    # Buscar el final de una oraci√≥n cerca del l√≠mite
    truncated = text[:max_length]
    
    # Buscar punto, signo de exclamaci√≥n o interrogaci√≥n
    for punct in ['.', '!', '?']:
        last_punct = truncated.rfind(punct)
        if last_punct > max_length - 50:  # Si est√° cerca del final
            return truncated[:last_punct + 1] + "..."
    
    # Si no hay puntuaci√≥n, buscar el final de una palabra
    last_space = truncated.rfind(' ')
    if last_space > max_length - 20:
        return truncated[:last_space] + "..."
    
    return truncated + "..."

def _extract_summary(text: str) -> str:
    """
    Extrae un resumen de las primeras l√≠neas del documento
    """
    lines = text.split('\n')
    summary_lines = []
    char_count = 0
    
    for line in lines[:5]:  # Primeras 5 l√≠neas
        if char_count + len(line) > 200:
            break
        summary_lines.append(line.strip())
        char_count += len(line)
    
    return ' '.join(summary_lines)

def _extract_keywords(text: str) -> List[str]:
    """
    Extrae palabras clave relevantes del texto
    """
    # Palabras clave comunes en documentos judiciales
    judicial_terms = [
        'demanda', 'sentencia', 'recurso', 'apelaci√≥n', 'casaci√≥n',
        'amparo', 'constitucional', 'civil', 'penal', 'laboral',
        'contencioso', 'administrativo', 'familia', 'violencia',
        'alimentos', 'divorcio', 'custodia', 'pensi√≥n'
    ]
    
    text_lower = text.lower()
    found_keywords = []
    
    for term in judicial_terms:
        if term in text_lower:
            found_keywords.append(term)
    
    return found_keywords[:5]  # M√°ximo 5 palabras clave

# Nueva funci√≥n para informaci√≥n espec√≠fica de expedientes
def format_expediente_detailed(docs: List[Document], expediente_numero: str = "") -> str:
    """
    Formato espec√≠fico para cuando se solicita informaci√≥n detallada de expedientes
    """
    if not docs:
        return "No se encontr√≥ informaci√≥n para el expediente solicitado."
    
    # Filtrar por expediente espec√≠fico si se proporciona
    if expediente_numero:
        docs = [doc for doc in docs if doc.metadata.get("expediente_numero") == expediente_numero]
    
    if not docs:
        return f"No se encontr√≥ informaci√≥n para el expediente {expediente_numero}."
    
    result = "üîç **INFORMACI√ìN DETALLADA DEL EXPEDIENTE**\n\n"
    
    for i, doc in enumerate(docs, 1):
        exp = doc.metadata.get("expediente_numero", "N/A")
        result += f"üìã **EXPEDIENTE: {exp}**\n"
        result += f"‚öñÔ∏è Materia: {doc.metadata.get('materia', 'Sin especificar')}\n"
        result += f"üèõÔ∏è Sede: {doc.metadata.get('sede_judicial', 'Sin especificar')}\n"
        result += f"üìÖ Fecha: {doc.metadata.get('fecha', 'Sin especificar')}\n"
        result += f"üìÑ Tipo: {doc.metadata.get('tipo_documento', 'Sin especificar')}\n"
        result += f"üìÅ Archivo: {doc.metadata.get('archivo', 'Sin especificar')}\n\n"
        result += f"üìù **CONTENIDO COMPLETO:**\n{doc.page_content}\n"
        result += "\n" + "‚îÄ"*80 + "\n\n"
    
    return result

# Funciones optimizadas para velocidad
def format_documents_context_fast(docs: List[Document], max_docs: int = 8, max_chars_per_doc: int = 400) -> str:
    """
    Formatea documentos para el contexto del LLM - OPTIMIZADO PARA VELOCIDAD
    
    Args:
        docs: Lista de documentos de LangChain
        max_docs: N√∫mero m√°ximo de documentos (8 para velocidad √≥ptima)
        max_chars_per_doc: Caracteres m√°ximos por documento (400 para respuesta r√°pida)
    
    Returns:
        Contexto formateado optimizado para velocidad
    """
    if not docs:
        return "No hay informaci√≥n disponible."
    
    context_parts = []
    # REDUCIDO: M√°ximo 8 documentos para velocidad
    docs_to_use = docs[:min(len(docs), max_docs)]
    
    for i, doc in enumerate(docs_to_use, 1):
        expediente = doc.metadata.get("expediente_numero", "N/A")
        materia = doc.metadata.get("materia", "")
        sede_judicial = doc.metadata.get("sede_judicial", "")
        
        # REDUCIDO: 400 caracteres m√°ximo para velocidad
        content = _truncate_text_fast(doc.page_content, max_chars_per_doc)
        
        # Formato m√°s compacto
        header = f"**Doc {i}** - Exp: {expediente}"
        if materia:
            header += f" ({materia})"
        if sede_judicial:
            header += f" - {sede_judicial}"
            
        context_parts.append(f"{header}\n{content}")
    
    return "\n" + "‚îÄ"*40 + "\n".join(context_parts)

def format_context_compact_fast(docs: List[Document], max_docs: int = 5) -> str:
    """
    Versi√≥n ultra-compacta para m√°xima velocidad
    
    Args:
        docs: Lista de documentos de LangChain
        max_docs: N√∫mero m√°ximo de documentos (5 para velocidad m√°xima)
    
    Returns:
        Contexto ultra-compacto
    """
    if not docs:
        return "Sin informaci√≥n."
    
    context_parts = []
    
    for i, doc in enumerate(docs[:max_docs], 1):
        exp = doc.metadata.get("expediente_numero", "N/A")
        materia = doc.metadata.get("materia", "")
        
        # ULTRA-COMPACTO: Solo 200 caracteres
        content = _truncate_text_fast(doc.page_content, 200)
        
        # Formato m√≠nimo
        context_parts.append(f"**{i}.** {exp} ({materia}): {content}")
    
    return "\n\n".join(context_parts)

def _truncate_text_fast(text: str, max_length: int) -> str:
    """
    Truncado ultra-r√°pido sin buscar puntuaci√≥n (para velocidad)
    """
    if len(text) <= max_length:
        return text
    return text[:max_length] + "..."

def extract_document_sources_fast(docs: List[Document]) -> List[Dict[str, Any]]:
    """
    Extracci√≥n optimizada para velocidad
    """
    fuentes = []
    # L√çMITE: Solo primeros 5 documentos para velocidad
    for doc in docs[:5]:
        fuente = {
            "expediente": doc.metadata.get("expediente_numero", ""),
            "materia": doc.metadata.get("materia", ""),
            "sede_judicial": doc.metadata.get("sede_judicial", ""),
            "relevancia": doc.metadata.get("relevance_score", 0),
            "fragmento": _truncate_text_fast(doc.page_content, 150)  # MUY REDUCIDO
        }
        fuentes.append(fuente)
    return fuentes

def format_context_compact(docs: List[Document], max_docs: int = 12) -> str:
    """
    Versi√≥n "compacta" pero con informaci√≥n sustancial para expedientes
    
    Args:
        docs: Lista de documentos de LangChain
        max_docs: N√∫mero m√°ximo de documentos a incluir (12 para informaci√≥n completa)
    
    Returns:
        Contexto con informaci√≥n detallada pero organizada
    """
    if not docs:
        return "Sin informaci√≥n de expedientes disponible."
    
    context_parts = []
    
    for i, doc in enumerate(docs[:max_docs], 1):
        exp = doc.metadata.get("expediente_numero", "N/A")
        materia = doc.metadata.get("materia", "Sin especificar")
        sede = doc.metadata.get("sede_judicial", "Sin sede")
        fecha = doc.metadata.get("fecha", "Sin fecha")
        tipo_doc = doc.metadata.get("tipo_documento", "Sin tipo")
        relevancia = doc.metadata.get("relevance_score", 0)
        
        # Aumentar SIGNIFICATIVAMENTE el contenido: 700 caracteres
        content = _truncate_text_smart(doc.page_content, 700)
        
        # Header m√°s informativo
        header = f"**üìã EXPEDIENTE {i}: {exp}**"
        metadata_line = f"‚öñÔ∏è {materia} | üèõÔ∏è {sede} | üìÖ {fecha} | üìÑ {tipo_doc} | üéØ Rel: {relevancia:.2f}"
        
        context_parts.append(f"{header}\n{metadata_line}\n\nüìù **Contenido Detallado:**\n{content}")
    
    return "\n\n" + "="*60 + "\n\n".join(context_parts) + "\n\n" + "="*60